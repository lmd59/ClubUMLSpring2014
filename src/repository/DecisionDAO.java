package repository;


import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;

import domain.Decision;
import domain.Rationale;

public class DecisionDAO {


	public static boolean addDecision(Decision decision) {
		ResultSet rs;

		try {
			
			//create prepared statement
			Connection conn = DbManager.getConnection();
			PreparedStatement pstmt = conn
					.prepareStatement(
							"INSERT into decision(decisionName, projectId, decisionTime, userId, diagramId) VALUES(?,?,?,?,?);",
							Statement.RETURN_GENERATED_KEYS);
			pstmt.setString(1, decision.getDecisionName());			
			pstmt.setInt(2, decision.getProjectId());
			pstmt.setDate(3, decision.getDecisionTime());
			pstmt.setInt(4, decision.getUserId());
			pstmt.setInt(5, decision.getDiagramId());
			
			// Execute the SQL statement and update database accordingly.
			pstmt.executeUpdate();

			// Get userId generated by DB back, and set it in user object
			rs = pstmt.getGeneratedKeys();
			if (rs.next()) {
				int newId = rs.getInt(1);
				decision.setDecisionId(newId);
				
				for(Integer rationaleId:decision.getRationaleIds()){
					PreparedStatement psRationale = conn.prepareStatement("INSERT into decisionRationale(decisionId, rationaleId) VALUES(?,?);");
					psRationale.setInt(1, decision.getDecisionId());
					psRationale.setInt(2, rationaleId);
					
					psRationale.executeUpdate();
					psRationale.close();
				}
			}
			
			
			rs.close();
			pstmt.close();
			conn.close();
		} catch (SQLException e) {
			throw new IllegalArgumentException(e.getMessage(), e);
		}
		return true;
	}
	
	
	public static Decision getDecision(int decisionId) {
		try {
			Connection conn = DbManager.getConnection();
			PreparedStatement pstmt;
			pstmt = conn.prepareStatement("SELECT * FROM decision where decisionId = ?;");
			pstmt.setInt(1, decisionId);
			
			// Execute the SQL statement and store result into the ResultSet
			ResultSet rs = pstmt.executeQuery();

			if(rs.next()){
				Decision decision;
				decision = new Decision();
				decision.setDecisionId(rs.getInt("decisionId"));
				decision.setProjectId(rs.getInt("projectId"));
				decision.setDecisionTime(rs.getDate("decisionTime"));
				decision.setUserId(rs.getInt("userId"));
				decision.setUserName(UserDAO.getUser(rs.getInt("userId")).getUserName());
				decision.setDiagramName(DiagramDAO.getDiagram(rs.getInt("diagramId")).getDiagramName());
				decision.setDiagramId(rs.getInt("diagramId"));
				decision.setRationaleIds(DecisionDAO.getRationaleIds(rs.getInt("decisionId")));
				
				rs.close();
				pstmt.close();
				conn.close();
				return decision;
			}
			else return null;			
		} catch (SQLException e) {
			System.out.println(e.getMessage());
			System.out.println("Using default model.");
		}

		return null;
	}
	
	public static ArrayList<Integer> getRationaleIds(int decisionId) throws SQLException{
		ArrayList<Integer> rationaleIds = new ArrayList<Integer>();
		Connection conn = null;
    	PreparedStatement pstmt = null;
    	ResultSet rs = null;
    	try {
    		conn = DbManager.getConnection();
    	    pstmt = conn.prepareStatement(
    		    "SELECT * FROM decisionRationale where decisionId = ?;");
    	    pstmt.setInt(1, decisionId);
    	    rs = pstmt.executeQuery();
    	    while (rs.next()) {
    		
    	    	Integer rationaleId = rs.getInt("rationaleId");
    	    	rationaleIds.add(rationaleId);
    	    }
    	    return rationaleIds;
    	} catch (SQLException e) {
    		e.printStackTrace();
    	} finally {
    		if( rs != null) {rs.close();}
    		if( pstmt != null) {pstmt.close();}
    		if( conn != null) {conn.close();}
    	}
		return rationaleIds;
		
	}
	
	//returns all of the latest decisions for a given project- i.e. the latest decision for each decision name
	public static HashMap<String, Decision> getLatestDecisions(int projectId) throws SQLException{
		ArrayList<Decision> decisions = new ArrayList<Decision>();
		HashMap<String, Decision> latestDecisions = new HashMap<String, Decision>();
		Connection conn = null;
    	PreparedStatement pstmt = null;
    	ResultSet rs = null;
    	try {
    		conn = DbManager.getConnection();
    	    pstmt = conn.prepareStatement(
    		    "SELECT * FROM decision where projectId = ?;");
    	    pstmt.setInt(1, projectId);
    	    rs = pstmt.executeQuery();
    	    while (rs.next()) {
    	    	Decision decision;
				decision = new Decision();
				decision.setDecisionId(rs.getInt("decisionId"));
				decision.setProjectId(rs.getInt("projectId"));
				decision.setDecisionTime(rs.getDate("decisionTime"));
				decision.setUserId(rs.getInt("userId"));
				decision.setUserName(UserDAO.getUser(rs.getInt("userId")).getUserName());
				decision.setDiagramName(DiagramDAO.getDiagram(rs.getInt("diagramId")).getDiagramName());
				decision.setDiagramId(rs.getInt("diagramId"));
				decision.setRationaleIds(DecisionDAO.getRationaleIds(rs.getInt("decisionId")));
	    		decisions.add(decision);
    	    }
    	    
    	    for(Decision decision: decisions){
    	    	Decision existingDecision = latestDecisions.get(decision.getDecisionName());
    	    	if(existingDecision==null || existingDecision.getDecisionTime().before(decision.getDecisionTime())){
    	    		//only replace decision if this decision is the newer one for the same name
    	    		latestDecisions.put(decision.getDecisionName(), decision);
    	    	}
    	    }
    	    
    	    return latestDecisions;
    	} catch (SQLException e) {
    		e.printStackTrace();
    	} finally {
    		if( rs != null) {rs.close();}
    		if( pstmt != null) {pstmt.close();}
    		if( conn != null) {conn.close();}
    	}
    	
		return latestDecisions;
	}
	

	public static boolean deleteDecision(Decision decision) {
		if (decision == null) {
			return false;
		}
		try {
			Connection conn = DbManager.getConnection();
			PreparedStatement pstmt = conn
					.prepareStatement("DELETE FROM decision where decisionId = ?;");
			pstmt.setInt(1, decision.getDecisionId());

			// Execute the SQL statement and update database accordingly.
			pstmt.executeUpdate();

			pstmt.close();
			conn.close();
			return true;
		} catch (SQLException e) {
			throw new IllegalArgumentException(e.getMessage(), e);
		}
	}

}
